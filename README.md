# Лабораторная работа №3: Сравнение производительности коллекций

## Описание проекта

Данный проект предназначен для практического сравнения производительности двух популярных реализаций интерфейса `List` в Java: `ArrayList` и `LinkedList`.

Программа выполняет замеры времени для основных операций (добавление, чтение, удаление) в различных сценариях: в начале, в середине и в конце списка.

## Технологии

*   Java 24 (Corretto)
*   Maven

## Как запустить проект

1.  **Клонируйте репозиторий:**
    ```bash
    git clone https://github.com/Syxarik2005/java-lab3.git
    cd java-lab3
    ```
2.  **Скомпилируйте и запустите:**
    Проект не требует сборки, его можно запустить напрямую из IDE (класс `Main.java`).

## Результаты тестов и их анализ

Ниже представлены результаты выполнения тестов на 100,000 операций и их теоретическое обоснование.

### Тестирование ArrayList

| Метод                     | Количество        | Время (ms) |
| ------------------------- | ----------------- | ---------- |
| Добавление в конец        | 100000            | 3          |
| Чтение из середины        | 100000            | 1          |
| Добавление в середину     | 100000            | 600        |
| Удаление с конца          | 100000            | 2          |
| Добавление в начало       | 100000            | 361        |
| Удаление из начала        | 100000            | 332        |

**Анализ:**
*   **`get` (чтение):** `ArrayList` показывает феноменальную скорость (`O(1)`). Это его главный плюс, так как он основан на массиве и может получить доступ к любому элементу по индексу напрямую.
*   **`add` (в конец) и `remove` (с конца):** Эти операции также очень быстрые (`O(1)` в среднем), так как в большинстве случаев не требуют копирования всего массива.
*   **`add`/`remove` (в начало/середину):** Это худший сценарий для `ArrayList` (`O(n)`). Каждая такая операция заставляет сдвигать все последующие элементы, что приводит к огромным временным затратам.

### Тестирование LinkedList

| Метод                     | Количество        | Время (ms) |
| ------------------------- | ----------------- | ---------- |
| Добавление в конец        | 100000            | 1          |
| Чтение из середины        | 100000            | 5736       |
| Добавление в середину     | 100000            | 5800       |
| Удаление с конца          | 100000            | 3          |
| Добавление в начало       | 100000            | 1          |
| Удаление из начала        | 100000            | 1          |

**Анализ:**
*   **`add`/`remove` (в начало/конец):** `LinkedList` здесь абсолютный чемпион (`O(1)`). Ему нужно всего лишь переназначить пару ссылок, что происходит мгновенно.
*   **`get` (чтение) и операции в середине:** Это катастрофически медленно (`O(n)`). Чтобы найти элемент в середине, `LinkedList` должен последовательно пройти по всем ссылкам от начала или конца списка. Это его главная слабость.

## Вывод

Проведенные тесты наглядно демонстрируют фундаментальные различия в устройстве `ArrayList` и `LinkedList`.

*   **`ArrayList`** — идеальный выбор, когда основной операцией является чтение данных по индексу.
*   **`LinkedList`** — незаменим, когда требуется часто вставлять или удалять элементы в начало или конец списка (например, при реализации очередей или стеков).

## Автор

*   **Имя:** Белявцев Сергей
*   **Группа:** 7